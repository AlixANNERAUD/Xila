from pygccxml import utils
from pygccxml import declarations as Declarations
from pygccxml import parser as Parser
import os
from Basics import *
from Bindings import *
import json
import re

def Get_Header_File_Paths(Folder_Path):
    Headers_File_Paths = []
    for Item in os.listdir(Folder_Path):
        Item_Path = os.path.join(Folder_Path, Item)
        if os.path.isdir(Item_Path):
            Headers_File_Paths.append(Get_Header_File_Paths(Item_Path))
        elif os.path.isfile(Item_Path) and Item_Path.endswith(".hpp"):
            if Item_Path.endswith(".hpp"):
                Headers_File_Paths.append(Item_Path)

def Generate_Class(Class):
    File_Path = os.path.join(os.path.dirname(__file__), "./" + Get_Name(Class) + ".cpp")

    if os.path.exists(File_Path):
        os.remove(File_Path)

    Generated_File = open(File_Path, "w")

    # print(Get_Header_File_Paths(os.path.dirname(__file__)))

    Generated_File.write("// This file is automatically generated by the Generate.py script.\n")
    Generated_File.write("#include \"be_constobj.h\"\n")
    Generated_File.write("#include \"be_mapping.h\"\n")


    Generated_File.write("\n// - Functions\n")
    # Constructors
    Generated_File.write("\n// - - Constructors\n")
    for Member in Class.get_members():
        if (Is_Constructor(Member)):
             Generated_File.write(Get_Binding_Function(Member) + "\n")
             Generated_File.write(Get_Binding_Function_Declaration(Member) + "\n")

    Generated_File.write("\n// - - Destructors\n")

    # Destructor
    for Member in Class.get_members():
        if (Is_Destructor(Member)):
            Generated_File.write(Get_Binding_Function(Member) + "\n")
            Generated_File.write(Get_Binding_Function_Declaration(Member) + "\n")

    Generated_File.write("\n// - - Functions\n")

    # Function
    for Member in Class.get_members():
        if(Is_Function(Member)):
            Generated_File.write(Get_Binding_Function(Member) + "\n")
            Generated_File.write(Get_Binding_Function_Declaration(Member) + "\n")

    # Berry declaration part

    Generated_File.write("\n// - Berry declaration\n")
    Generated_File.write(Get_Class_Binding_Declaration(Class) + "\n")

    # Include the berry header

    Module_Name = "test".lower()

    Generated_File.write("\nextern \"C\"\n{\n")
    Generated_File.write("\t#include \"../generate/be_Fixed_.h\"\n")
    Generated_File.write("\t#include \"../generate/be_fixed_be_class_bar.h\"\n")
    Generated_File.write("}")

    Generated_File.close()


def Generate(Declarations):
    for Declaration in Declarations:
        if (Is_Namespace(Declaration)):
            print("Namespace : " + Get_Name(Declaration))
            Generate(Declaration)
        elif (Is_Class(Declaration)):    
            print("Class : " + Get_Name(Declaration))
            Generate_Class(Declaration)

# Find the location of the xml generator (castxml or gccxml)
generator_path, generator_name = utils.find_xml_generator()



# The C++ file we want to parse

compile_commands_path = os.path.join(os.path.dirname(__file__), "compile_commands.json")

Compile_Commands_File = open(compile_commands_path, "r")

Compile_Commands = json.load(Compile_Commands_File)

Commands = ""

for Command in Compile_Commands:
    Commands += Command["command"]

I_Flags_Raw = re.findall(r'-I([^\s]+)', Commands)

D_Flags_Raw = re.findall(r'-D([^\s]+)', Commands)

D_Flags_Raw.append("min(x,y)=true")

D_Flags = []

for Flag in D_Flags_Raw:
    if Flag not in D_Flags:
        D_Flags.append(Flag)

I_Flags = []

I_Flags_Raw.append(".pio/libdeps/wt32-sc01-plus/Battery Library/src")

for Flag in I_Flags_Raw:
    if Flag not in I_Flags:
        I_Flags.append(Flag)

for Flag in I_Flags:
    if not(Flag.startswith("/home")):
        Flag = "/home/alix_anneraud/Git/Xila/Code/" + Flag
    
# Configure the xml generator
xml_generator_config = Parser.xml_generator_configuration_t(
    xml_generator_path=generator_path,
    xml_generator=generator_name,
    compiler_path="/home/alix_anneraud/.platformio/packages/toolchain-xtensa-esp32s3/bin/xtensa-esp32s3-elf-g++",
    define_symbols=D_Flags,
    cflags="-m32 -fpermissive -fsyntax-only -ferror-limit=200 -std=gnu++11 -Wignored-attributes -fexceptions -fms-extensions -frtti  -mlong-calls -ffunction-sections -fdata-sections -Wno-error=unused-function -Wno-error=unused-variable -Wno-error=deprecated-declarations -Wno-unused-parameter -Wno-sign-compare -ggdb -freorder-blocks -Wwrite-strings -fstack-protector -Wno-error=unused-but-set-variable -fno-jump-tables -MMD -Og -g2 -ggdb2",
    include_paths=I_Flags
)

Headers = [os.path.join(os.path.dirname(__file__), "..", "..", "..", "..", "..", "include", "Xila.hpp")]
#Headers = [os.path.join(os.path.dirname(__file__), "..", "Modules", "test.hpp")]

# Parse the c++ file
Dec = Parser.parse(Headers, xml_generator_config)

# Get access to the global namespace
Global_Namespace = Declarations.get_global_namespace(Dec)

# Get access to the "ns" namespace

Xila_Namespace = Global_Namespace.namespace("Xila_Namespace")


Graphics_Namespace = Xila_Namespace.namespace("Graphics_Types")

for D in Graphics_Namespace.declarations:
    print(D)
    
Modules = os.listdir(os.path.join(os.path.dirname(__file__), "..", "..", "..", "..", "..", "include", "Core"))

print(Modules)

Generate(Global_Namespace.declarations)